#include <stdint.h>
#include "../include/idt.h"
#include "../include/graphics.h"
#include "../include/memory.h"
#include "../include/ports.h"

#define XHCI_TRB_TYPE_EVENT_TRANSFER_EVENT 32
#define XHCI_TRB_TYPE_EVENT_COMMAND_COMPLETION_EVENT 33
#define XHCI_TRB_TYPE_EVENT_PORT_STATUS_CHANGE_EVENT 34
#define XHCI_TRB_TYPE_EVENT_BANDWIDTH_REQUEST_EVENT 35
#define XHCI_TRB_TYPE_EVENT_DOORBELL_EVENT 36
#define XHCI_TRB_TYPE_EVENT_HOST_CONTROLLER_EVENT 37
#define XHCI_TRB_TYPE_EVENT_DEVICE_NOTIFICATION_EVENT 38
#define XHCI_TRB_TYPE_EVENT_MFINDEX_WRAP_EVENT 39

void initialise_xhci_driver(unsigned long addr,unsigned long interrupt);

typedef struct{
    uint8_t caplength;
    uint8_t rsvd;
    uint16_t hciversion;
    uint32_t hcsparams1;
    uint32_t hcsparams2;
    uint32_t hcsparams3;
    uint32_t hccparams1;
    uint32_t dboff;
    uint32_t rtsoff;
    uint32_t hccparams2;
}__attribute__((packed)) XHCICapabilityRegisters;

typedef struct{
    uint32_t portsc;
    uint32_t portpmsc;
    uint32_t portli;
    uint32_t porthlpmc;
}__attribute__((packed)) XHCIPortRegister;

typedef struct{
    uint32_t usbcmd;
    uint32_t usbsts;
    uint32_t pagesize;
    uint8_t rsvdA[0x08];
    uint32_t dnctrl;
    uint64_t crcr;
    uint8_t rsvdB[0x10];
    uint64_t dcbaap;
    uint32_t config;
    uint8_t rsvdC[0x3C4];
    XHCIPortRegister ports[30];
}__attribute__((packed)) XHCIOperationalRegisters;

typedef struct{
    uint32_t iman;
    uint32_t imod;
    uint32_t erstsz;
    uint32_t reserved;
    uint64_t erstba;
    uint64_t erdp;
}__attribute__((packed)) XHCIInterrupterRegisters;

typedef struct{
    uint32_t mfindex;
    uint8_t reserved[0x1C];
    XHCIInterrupterRegisters intregs[10];
}__attribute__((packed)) XHCIRuntimeRegisters;

typedef struct{
    uint64_t address;
    uint32_t ringsegmentsize;
    uint32_t rsvd;
}__attribute__((packed)) XHCIEventRingSegmentTableEntry;

typedef struct{
    // TRB Pointer Hi and Lo. This field represents the 64-bit address of the TRB that generated this
    // event or 64 bits of Event Data if the ED flag is ‘1’.
    // If a TRB memory structure is referenced by this field (ED = ‘0’), then it shall be physical memory
    // pointer aligned on a 16-byte boundary, i.e. bits 0 through 3 of the address are ‘0’.
    uint64_t trb_pointer;
    // TRB Transfer Length. This field shall reflect the residual number of bytes not transferred.
    // For an OUT, this field shall indicate the value of the Length field of the Transfer TRB, minus the
    // data bytes that were successfully transmitted. A successful OUT transfer shall return a Length of
    // ‘0’.
    // For an IN, this field shall indicate the value of the TRB Transfer Length field of the Transfer TRB,
    // minus the data bytes that were successfully received. If the device terminates the receive
    // transfer with a Short Packet, then this field shall indicate the difference between the expected
    // transfer size (defined by the Transfer TRB) and the actual number of bytes received. If the
    // receive transfer completed with an error, then this field shall indicate the difference between
    // the expected transfer size and the number of bytes successfully received.
    // If the Event Data flag is ‘0’ the legal range of values is 0 to 10000h. If the Event Data flag is ‘1’ or
    // the Condition Code is Stopped - Short Packet, then this field shall be set to the value of the
    // Event Data Transfer Length Accumulator (EDTLA). Refer to section 4.11.5.2 for a description of
    // EDTLA.
    uint32_t transfer_length: 24;
    // Completion Code. This field encodes the completion status that can be identified by a TRB.
    // Refer to section 6.4.5 for an enumerated list of possible error conditions.
    uint32_t competion_code: 7;
    // Cycle bit (C). This bit is used to mark the Dequeue Pointer of an Event Ring.
    uint8_t cycle_bit: 1;
    // RsvdZ.
    uint8_t reserved_1: 1;
    // Event Data (ED). When set to ‘1’, the event was generated by an Event Data TRB and the
    // Parameter Component (TRB Pointer field) contains a 64-bit value provided by the Event Data
    // TRB. If cleared to ‘0’, the Parameter Component (TRB Pointer field) contains a pointer to the TRB
    // that generated this event. Refer to section 4.11.5.2 for more information.
    uint8_t event_data: 1;
    uint16_t reserved_2: 7;
    // TRB Type. This field identifies the type of the TRB. Refer to Table 6-91 for the definition of the
    // Transfer Event TRB type ID.
    uint16_t trb_type: 6;
    // Endpoint ID. The ID of the Endpoint that generated the event. This value is used as an index in
    // the Device Context to select the Endpoint Context associated with this event.
    uint16_t endpoint_id: 5;
    uint8_t reserved_3: 3;
    // Slot ID. The ID of the Device Slot that generated the event. This is value is used as an index in
    // the Device Context Base Address Array to select the Device Context of the source device.
    uint16_t slot_id: 7;
}__attribute__((packed))TransferEventTRB;

unsigned long baseaddr;

XHCICapabilityRegisters* capability_registers;
XHCIOperationalRegisters* operational_registers;
XHCIRuntimeRegisters* runtime_registers;
unsigned long *dcbaap;
void *command_ring_control;
TransferEventTRB *event_ring_control;

TransferEventTRB eventringtemplate[30] __attribute__((aligned(0x1000)));
TransferEventTRB commandringtemplate[30] __attribute__((aligned(0x1000)));
TransferEventTRB dcbaapringtemplate[30] __attribute__((aligned(0x1000)));
XHCIEventRingSegmentTableEntry eventringsegmenttableentry __attribute__((aligned(0x1000)));

__attribute__((interrupt)) void xhci_interrupt(interrupt_frame* frame){
    uint32_t oldstatus = operational_registers->usbsts;
    k_printf("Interrupt: XHCI-interrupt with code %x \n",oldstatus);
    if(oldstatus & 0x08){
        k_printf("This was an event interrupt!\n");
        operational_registers->usbsts = 0x08;
    }
    if(oldstatus & 0x10){
        k_printf("This was an port interrupt!\n");
        operational_registers->usbsts = 0x10;
    }
    operational_registers->usbsts = oldstatus;
    runtime_registers->intregs[0].iman = 3;
    // asm volatile("cli\nhlt");
	outportb(0xA0,0x20);
	outportb(0x20,0x20);
}

void initialise_xhci_driver(unsigned long ba,unsigned long ints){
    requestPage();
    baseaddr = ba & 0xFFFFFF00;
    // k_printf("xhci: the xhci memory registers are stored at %x with int %x function at %x \n",baseaddr,ints,xhci_interrupt);
    // sayhi();
    setInterrupt(ints,xhci_interrupt);
    capability_registers = (XHCICapabilityRegisters*) baseaddr;
    operational_registers = (XHCIOperationalRegisters*)(baseaddr + capability_registers->caplength);
    runtime_registers = (XHCIRuntimeRegisters*)(baseaddr + capability_registers->rtsoff);
    
    // k_printf("DBG: erdp:%x erstba:%x erstsz:%x iman:%x imod:%x \n",runtime_registers->intregs[0].erdp,runtime_registers->intregs[0].erstba,runtime_registers->intregs[0].erstsz,runtime_registers->intregs[0].iman,runtime_registers->intregs[0].imod);
    XHCIEventRingSegmentTableEntry *stufu = (XHCIEventRingSegmentTableEntry*) runtime_registers->intregs[0].erstba;
    // k_printf("DBG: address:%x ringsegmentsize:%x \n",stufu->address,stufu->ringsegmentsize);
    // k_printf("DBG: dcbaap:%x \n",operational_registers->dcbaap);
    uint64_t eww = operational_registers->dcbaap;

    //
    // trigger reset 

    operational_registers->usbcmd |= 2;
    k_printf("xhci: reset controller\n");
    // reset
    while(operational_registers->usbcmd & 2);

    // k_printf("DBG: erdp:%x erstba:%x erstsz:%x iman:%x imod:%x \n",runtime_registers->intregs[0].erdp,runtime_registers->intregs[0].erstba,runtime_registers->intregs[0].erstsz,runtime_registers->intregs[0].iman,runtime_registers->intregs[0].imod);
    
    // set the portcount
    operational_registers->config |= (capability_registers->hcsparams1>>24) & 0xFF;

    event_ring_control = (TransferEventTRB*) &eventringtemplate;
    memset(event_ring_control,0,0x1000);
    XHCIEventRingSegmentTableEntry* erse = (XHCIEventRingSegmentTableEntry*) &eventringsegmenttableentry;
    memset(erse,0,sizeof(XHCIEventRingSegmentTableEntry));
    erse->address = (uint64_t) event_ring_control;
    erse->ringsegmentsize = 0x40;
    runtime_registers->intregs[0].iman = 2;
    runtime_registers->intregs[0].erstsz = 1;
    runtime_registers->intregs[0].erdp = (uint64_t) event_ring_control;
    runtime_registers->intregs[0].erstba = (uint64_t) erse;

    // set crcr
    command_ring_control = (void*)&commandringtemplate;
    memset(command_ring_control,0,0x1000);
    operational_registers->crcr = ((uint64_t)command_ring_control) | 1;

    // set bcbaap
    dcbaap = (unsigned long*) &dcbaapringtemplate;
    memset(dcbaap,0,0x1000);
    operational_registers->dcbaap = (uint64_t) eww;

    // k_printf("DBG: erdp:%x erstba:%x erstsz:%x iman:%x imod:%x \n",runtime_registers->intregs[0].erdp,runtime_registers->intregs[0].erstba,runtime_registers->intregs[0].erstsz,runtime_registers->intregs[0].iman,runtime_registers->intregs[0].imod);
    // k_printf("DBG: address:%x ringsegmentsize:%x \n",erse->address,erse->ringsegmentsize);
    

    // run!
    operational_registers->usbcmd |= 0b101;
    sleep(5);
    for(int i = 0 ; i < 10 ; i++){
        k_printf("%d: %x %x %x \n",i,operational_registers->ports[i].portsc,event_ring_control[i].cycle_bit,event_ring_control[i].trb_type);
        sleep(1);
    }
    k_printf("if we hit this point, everything is finished!\n");for(;;);
}