#include <stdint.h>
#include "../include/idt.h"
#include "../include/graphics.h"
#include "../include/memory.h"
#include "../include/ports.h"
#include "../include/timer.h"

#define XHCI_TRB_TYPE_EVENT_TRANSFER_EVENT 32
#define XHCI_TRB_TYPE_EVENT_COMMAND_COMPLETION_EVENT 33
#define XHCI_TRB_TYPE_EVENT_PORT_STATUS_CHANGE_EVENT 34
#define XHCI_TRB_TYPE_EVENT_BANDWIDTH_REQUEST_EVENT 35
#define XHCI_TRB_TYPE_EVENT_DOORBELL_EVENT 36
#define XHCI_TRB_TYPE_EVENT_HOST_CONTROLLER_EVENT 37
#define XHCI_TRB_TYPE_EVENT_DEVICE_NOTIFICATION_EVENT 38
#define XHCI_TRB_TYPE_EVENT_MFINDEX_WRAP_EVENT 39

void initialise_xhci_driver(unsigned long addr,unsigned long interrupt);

typedef struct{
    uint8_t caplength;
    uint8_t rsvd;
    uint16_t hciversion;
    uint32_t hcsparams1;
    uint32_t hcsparams2;
    uint32_t hcsparams3;
    uint32_t hccparams1;
    uint32_t dboff;
    uint32_t rtsoff;
    uint32_t hccparams2;
}__attribute__((packed)) XHCICapabilityRegisters;

typedef struct{
    uint32_t portsc;
    uint32_t portpmsc;
    uint32_t portli;
    uint32_t porthlpmc;
}__attribute__((packed)) XHCIPortRegister;

typedef struct{
    uint32_t usbcmd;
    uint32_t usbsts;
    uint32_t pagesize;
    uint8_t rsvdA[0x08];
    uint32_t dnctrl;
    uint64_t crcr;
    uint8_t rsvdB[0x10];
    uint64_t dcbaap;
    uint32_t config;
    uint8_t rsvdC[0x3C4];
    XHCIPortRegister ports[30];
}__attribute__((packed)) XHCIOperationalRegisters;

typedef struct{
    uint32_t iman;
    uint32_t imod;
    uint32_t erstsz;
    uint32_t reserved;
    uint64_t erstba;
    uint64_t erdp;
}__attribute__((packed)) XHCIInterrupterRegisters;

typedef struct{
    uint32_t mfindex;
    uint8_t reserved[0x1C];
    XHCIInterrupterRegisters intregs[10];
}__attribute__((packed)) XHCIRuntimeRegisters;

typedef struct{
    uint64_t address;
    uint32_t ringsegmentsize;
    uint32_t rsvd;
}__attribute__((packed)) XHCIEventRingSegmentTableEntry;

typedef struct{
    // TRB Pointer Hi and Lo. This field represents the 64-bit address of the TRB that generated this
    // event or 64 bits of Event Data if the ED flag is ‘1’.
    // If a TRB memory structure is referenced by this field (ED = ‘0’), then it shall be physical memory
    // pointer aligned on a 16-byte boundary, i.e. bits 0 through 3 of the address are ‘0’.
    uint64_t trb_pointer;
    // TRB Transfer Length. This field shall reflect the residual number of bytes not transferred.
    // For an OUT, this field shall indicate the value of the Length field of the Transfer TRB, minus the
    // data bytes that were successfully transmitted. A successful OUT transfer shall return a Length of
    // ‘0’.
    // For an IN, this field shall indicate the value of the TRB Transfer Length field of the Transfer TRB,
    // minus the data bytes that were successfully received. If the device terminates the receive
    // transfer with a Short Packet, then this field shall indicate the difference between the expected
    // transfer size (defined by the Transfer TRB) and the actual number of bytes received. If the
    // receive transfer completed with an error, then this field shall indicate the difference between
    // the expected transfer size and the number of bytes successfully received.
    // If the Event Data flag is ‘0’ the legal range of values is 0 to 10000h. If the Event Data flag is ‘1’ or
    // the Condition Code is Stopped - Short Packet, then this field shall be set to the value of the
    // Event Data Transfer Length Accumulator (EDTLA). Refer to section 4.11.5.2 for a description of
    // EDTLA.
    uint32_t transfer_length: 24;
    // Completion Code. This field encodes the completion status that can be identified by a TRB.
    // Refer to section 6.4.5 for an enumerated list of possible error conditions.
    uint32_t competion_code: 7;
    
    // Slot ID. The ID of the Device Slot that generated the event. This is value is used as an index in
    // the Device Context Base Address Array to select the Device Context of the source device.
    uint32_t slot_id: 7;
    uint32_t reserved_3: 3;
    // Endpoint ID. The ID of the Endpoint that generated the event. This value is used as an index in
    // the Device Context to select the Endpoint Context associated with this event.
    uint32_t endpoint_id: 5;
    // TRB Type. This field identifies the type of the TRB. Refer to Table 6-91 for the definition of the
    // Transfer Event TRB type ID.
    uint32_t trb_type: 6;
    uint32_t reserved_2: 7;
    // Event Data (ED). When set to ‘1’, the event was generated by an Event Data TRB and the
    // Parameter Component (TRB Pointer field) contains a 64-bit value provided by the Event Data
    // TRB. If cleared to ‘0’, the Parameter Component (TRB Pointer field) contains a pointer to the TRB
    // that generated this event. Refer to section 4.11.5.2 for more information.
    uint32_t event_data: 1;
    // RsvdZ.
    uint32_t reserved_1: 1;
    // Cycle bit (C). This bit is used to mark the Dequeue Pointer of an Event Ring.
    uint32_t cycle_bit: 1;
}__attribute__((packed))TransferEventTRB;

typedef struct{
    uint32_t reserved[3];
    uint8_t cycle_bit:1;
    uint16_t reserved1:9;
    uint16_t trb_type:6;
    uint16_t slot_type:5;
    uint16_t reserved2:10;
}__attribute__((packed))EnableSlotTRB;

typedef struct{
    uint32_t arg1;
    uint32_t arg2;
    uint32_t arg3;
    uint32_t arg4;
}__attribute__((packed)) TRB;

typedef struct{
    // Command TRB Pointer Hi and Lo. This field represents the high order bits of the 64-bit address
    // of the Command TRB that generated this event. Note that this field is not valid for some
    // Completion Code values. Refer to Table 6-90 for specific cases.
    // The memory structure referenced by this physical memory pointer shall be aligned on a 16-byte
    // address boundary.
    uint64_t CommandTRBPointer;
    // Command Completion Parameter. This field may optionally be set by a command. Refer to
    // section 4.6.6.1 for specific usage. If a command does not utilize this field it shall be treated as
    // RsvdZ.
    uint32_t CommandCompletionParameter: 24;
    // Completion Code. This field encodes the completion status of the command that generated the
    // event. Refer to the respective command definition for a list of the possible Completion Codes
    // associated with the command. Refer to section 6.4.5 for an enumerated list of possible error
    // conditions.
    uint32_t CompletionCode:8;
    // This bit is used to mark the Dequeue Pointer of an Event Ring.
    uint8_t Cyclebit:1;
    uint16_t reserved1:9;
    // TRB Type. This field identifies the type of the TRB. Refer to Table 6-91 for the definition of the
    // Command Completion Event TRB type ID.
    uint16_t TRBType:6;
    // VF ID. The ID of the Virtual Function that generated the event. Note that this field is valid only if
    // Virtual Functions are enabled. If they are not enabled this field shall be cleared to ‘0’.
    uint16_t VFID:8;
    // Slot ID. The Slot ID field shall be updated by the xHC to reflect the slot associated with the
    // command that generated the event, with the following exceptions:
    // - The Slot ID shall be cleared to ‘0’ for No Op, Set Latency Tolerance Value, Get Port Bandwidth,
    // and Force Event Commands.
    // - The Slot ID shall be set to the ID of the newly allocated Device Slot for the Enable Slot
    // Command.
    // - The value of Slot ID shall be vendor defined when generated by a vendor defined command.
    // This value is used as an index in the Device Context Base Address Array to select the Device
    // Context of the source device. If this Event is due to a Host Controller Command, then this field
    // shall be cleared to ‘0’.
    uint16_t SlotID:8;
}__attribute__((packed)) CommandCompletionEventTRB;

unsigned long baseaddr;

XHCICapabilityRegisters* capability_registers;
XHCIOperationalRegisters* operational_registers;
XHCIRuntimeRegisters* runtime_registers;
uint64_t* dcbaap;
TRB *command_ring_control;
TRB *event_ring_control;
uint32_t *doorbells;

TRB eventringtemplate[30] __attribute__((aligned(0x1000)));
TRB commandringtemplate[0x1C7] __attribute__((aligned(0x1000)));
uint32_t dcbaapringtemplate[30];
XHCIEventRingSegmentTableEntry eventringsegmenttableentry __attribute__((aligned(0x1000)));

__attribute__((interrupt)) void xhci_interrupt(interrupt_frame* frame){
    uint32_t oldstatus = operational_registers->usbsts;
    k_printf("Interrupt: XHCI-interrupt with code %x \n",oldstatus);
    if(oldstatus & 0x08){
        k_printf("This was an event interrupt!\n");
        operational_registers->usbsts |= 0x08;
    }
    if(oldstatus & 0x10){
        k_printf("This was an port interrupt!\n");
        operational_registers->usbsts |= 0x10;
    }
    // operational_registers->usbsts = oldstatus;
    runtime_registers->intregs[0].iman = 3;
    k_printf("z: %x \n",operational_registers->usbsts);
    // asm volatile("cli\nhlt");
	outportb(0x20,0x20);
	outportb(0xA0,0x20);
}

void xhci_reset_hc(){
    operational_registers->usbcmd |= 2;
    k_printf("xhci: reset controller\n");
    // reset
    while(operational_registers->usbcmd & 2);
}


void xhci_setup(){
    uint64_t eww = operational_registers->dcbaap;

    if(operational_registers->usbcmd&1){
        k_printf("xhci: system is already running!\n");
        operational_registers->usbcmd &= ~1;
        sleep(2);
        if(operational_registers->usbcmd&1){
            k_printf("xhci: System is still running?!\n");
            for(;;);
        }
    }
    uint64_t extended_capabilities_addr = baseaddr + ((capability_registers->hccparams1&0xFFFF0000)>>14);
    // k_printf("xhci: daf %x \n",extended_capabilities_addr);
    uint64_t offsetx = 0;
    for(int i = 0 ; i < 20 ; i++){
        uint64_t tx = extended_capabilities_addr+offsetx;
        unsigned long fault = ((unsigned long*)tx)[0];
        unsigned char capid = fault & 0x00FF;
        unsigned char capof = (fault & 0xFF00)>>8;
        if(capid==0){
            break;
        }
        if(capid==1){
            k_printf("They say something about ownership...\n");
            for(;;);
        }
        offsetx += (capof*sizeof(unsigned long));
        if(capof==0){
            break;
        }
    }
    
    //
    // trigger reset 
    xhci_reset_hc();    

    // k_printf("DBG: erdp:%x erstba:%x erstsz:%x iman:%x imod:%x \n",runtime_registers->intregs[0].erdp,runtime_registers->intregs[0].erstba,runtime_registers->intregs[0].erstsz,runtime_registers->intregs[0].iman,runtime_registers->intregs[0].imod);
    
    // set the portcount
    operational_registers->config |= (capability_registers->hcsparams1>>24) & 0xFF;

    event_ring_control = (TRB*) &eventringtemplate;
    memset(event_ring_control,0,0x1000);
    XHCIEventRingSegmentTableEntry* erse = (XHCIEventRingSegmentTableEntry*) &eventringsegmenttableentry;
    memset(erse,0,sizeof(XHCIEventRingSegmentTableEntry));
    erse->address = (uint64_t) event_ring_control;
    erse->ringsegmentsize = 16;
    runtime_registers->intregs[0].iman = 2;
    runtime_registers->intregs[0].erstsz = 1;
    runtime_registers->intregs[0].erdp = (uint64_t) event_ring_control;
    runtime_registers->intregs[0].erstba = (uint64_t) erse;
    runtime_registers->intregs[0].imod = (10<<16) | 5;

    // set crcr
    command_ring_control = (void*)&commandringtemplate;
    memset(command_ring_control,0,0x2000);
    operational_registers->crcr = ((uint64_t)command_ring_control) ;//| 1;
    for(int i = 0 ; i <0x20 ; i++){
        if(operational_registers->crcr&1){
            command_ring_control[i].arg4 = 0;
        }else{
            command_ring_control[i].arg4 = 1;
        }
    }
    
    // set bcbaap
    dcbaap = (uint64_t*) &dcbaapringtemplate;
    // memset(dcbaap,0,0x1000);
    dcbaap[0] = ((uint64_t*)eww)[0];
    operational_registers->dcbaap = (uint64_t) eww;
}

void xhci_start(){
    operational_registers->usbcmd |= (1<<10) | (1<<3) | (1<<2) | 1;
}

int commandringoffset = 0;

uint8_t xhci_get_trb_result_of(TRB* erc){
    return (erc->arg3>>24)&0xFF;
}

uint8_t xhci_get_trb_type_of(TRB* erc){
    return (erc->arg4>>10)&0x3F;
}

void xhci_dump_event_ring(){
    for(int i = 0 ; i < 16 ; i++){
        TRB* erc = (TRB*) (event_ring_control + (sizeof(TRB)*i));
        if(erc->arg4&1){
            k_printf("%d: %x %x %x %x [%d:%d @ %x ]\n",i,erc->arg1,erc->arg2,erc->arg3,erc->arg4,xhci_get_trb_type_of(erc),xhci_get_trb_result_of(erc),erc);
        } 
    }
}

TRB* xhci_wait_for_event(TRB* origin){
    
    for(int z = 0 ; z < 25 ; z++){
        sleep(5);
        for(int i = 0 ; i < 16 ; i++){
            TRB* erc = (TRB*) (event_ring_control + (sizeof(TRB)*i));
            if( ((uint32_t)(((uint64_t)origin)&0xFFFFFFFF))==erc->arg1 && erc->arg4&1 ){
                return erc;
            } 
        }
        k_printf(".");
    }
    return 0;
}

uint16_t xhci_get_get_port_number(uint32_t portno){
    // EnableSlotTRB* est = (EnableSlotTRB*) (command_ring_control + (sizeof(TRB) * commandringoffset++));
    // est->cycle_bit = 1;
    // est->slot_type = 0;
    // est->trb_type = 9;

    TRB* est = (TRB*)(command_ring_control + (sizeof(TRB) * commandringoffset++));
    est->arg4 = (9<<10) | (operational_registers->crcr&1?1:0);
    doorbells[0] = 0;
    CommandCompletionEventTRB* completion_event = (CommandCompletionEventTRB*) xhci_wait_for_event((TRB*)est);
    if(!completion_event){
        xhci_dump_event_ring();
        k_printf("xhci_%d: no event found yet (timeout)!\n",portno);
        return 0;
    }
    k_printf("xhci_%d: type:%d code:%d slotid:%d \n",portno,completion_event->TRBType,completion_event->CompletionCode,completion_event->SlotID);
    if(completion_event->CompletionCode!=1){
        return 0;
    }
    return completion_event->SlotID;
}

uint8_t xhci_test_command_ring(){
    // no-op command
    k_printf(" sts:%x crcr:%x \n",operational_registers->usbsts,operational_registers->crcr);
    TRB* est = (TRB*)(command_ring_control + (sizeof(TRB) * commandringoffset++));
    est->arg4 = (23<<10) | (operational_registers->crcr&1?1:0);
    ((volatile uint32_t*)&doorbells[0])[0] = 0;
    TRB* res = xhci_wait_for_event(est);
    if(!res){
        k_printf("Command ring test failed! \n");
        return 0;
    }
    k_printf("Command ring test: %x %x %x %x\n",res->arg1,res->arg2,res->arg3,res->arg4);
    if( xhci_get_trb_type_of(res)==XHCI_TRB_TYPE_EVENT_COMMAND_COMPLETION_EVENT &&xhci_get_trb_result_of(res)==1 ){
        k_printf("Command ring test succeed!\n");
        return 1;
    }
    k_printf("Command ring test failed with trb type %d and resultcode %d \n",xhci_get_trb_type_of(res),xhci_get_trb_result_of(res));
    return 0;
}

void xhci_install_port(uint32_t portno){
    if(!(operational_registers->ports[portno].portsc & 1)){
        // hopeless, no port here!
        return;
    }
    k_printf("xhci_%d: there is something present on this port!\n",portno);
    // more hope... there oculd be a port here... do we need to reset it?
    if(!(operational_registers->ports[portno].portsc & 2)){
        // yes, we require a reset!
        k_printf("xhci_%d: reset required!\n",portno);
        operational_registers->ports[portno].portsc |= 0x10;
    }else{
        // no need for a reset
        k_printf("xhci_%d: no reset required!\n",portno);
    }
    sleep(3);
    k_printf("xhci_%d: initial state of the port: portsc:%x porthlpmc:%x portli:%x portpmsc:%x \n",portno,operational_registers->ports[portno].portsc,operational_registers->ports[portno].porthlpmc,operational_registers->ports[portno].portli,operational_registers->ports[portno].portpmsc);

    //
    // get deviceid
    uint16_t portnumber = xhci_get_get_port_number(portno);
    if(!portnumber){
        k_printf("xhci_%d: failed to get device id!\n",portno);
        return;
    }
    k_printf("xhci_%d: device_id=%d !\n",portno,portnumber);
    for(;;);
}

void initialise_xhci_driver(unsigned long ba,unsigned long ints){
    baseaddr = ba & 0xFFFFFF00;
    // k_printf("xhci: the xhci memory registers are stored at %x with int %x function at %x \n",baseaddr,ints,xhci_interrupt);
    // sayhi();
    setInterrupt(ints,xhci_interrupt);
    capability_registers = (XHCICapabilityRegisters*) baseaddr;
    operational_registers = (XHCIOperationalRegisters*)(baseaddr + capability_registers->caplength);
    runtime_registers = (XHCIRuntimeRegisters*)(baseaddr + capability_registers->rtsoff);
    doorbells = (uint32_t*) (baseaddr + capability_registers->dboff);

    // k_printf("DBG: erdp:%x erstba:%x erstsz:%x iman:%x imod:%x \n",runtime_registers->intregs[0].erdp,runtime_registers->intregs[0].erstba,runtime_registers->intregs[0].erstsz,runtime_registers->intregs[0].iman,runtime_registers->intregs[0].imod);
    // XHCIEventRingSegmentTableEntry *stufu = (XHCIEventRingSegmentTableEntry*) runtime_registers->intregs[0].erstba;
    // k_printf("DBG: address:%x ringsegmentsize:%x \n",stufu->address,stufu->ringsegmentsize);
    // k_printf("DBG: dcbaap:%x \n",operational_registers->dcbaap);
    xhci_setup();
    

    // k_printf("DBG: erdp:%x erstba:%x erstsz:%x iman:%x imod:%x \n",runtime_registers->intregs[0].erdp,runtime_registers->intregs[0].erstba,runtime_registers->intregs[0].erstsz,runtime_registers->intregs[0].iman,runtime_registers->intregs[0].imod);
    // k_printf("DBG: address:%x ringsegmentsize:%x \n",erse->address,erse->ringsegmentsize);
    

    // run!
    k_printf("Im running now!\n");
    xhci_start();
    // doing a test command...
    if(xhci_test_command_ring()){
        sleep(5);
        for(uint32_t i = 0 ; i < ((capability_registers->hcsparams1>>24) & 0xFF) ; i++){
            xhci_install_port(i);
        }
        xhci_test_command_ring();
    }else{
        k_printf("Failed to send a NOOP command. Aborting...\n");
    }
    xhci_dump_event_ring();
    k_printf("if we hit this point, everything is finished!\n");
}